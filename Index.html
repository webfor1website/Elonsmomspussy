<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="HyperChaoticNeuralCodec: A neon-yellow lightning-fucked XAI dream for Neuralink chaos.">
    <meta name="keywords" content="XAI, Neuralink, chaos, BCI, Python, TriadSynapse, SPARK">
    <title>HyperChaoticNeuralCodec - Fucking Unhinged Chaos</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-python.min.js"></script>
    <style>
        html, body { 
            background: linear-gradient(45deg, #666666, #999999) !important; 
            color: #333333; 
            font-family: 'Courier New', monospace; 
            overflow-x: hidden; 
            position: relative;
            animation: pulse-bg 5s infinite;
            margin: 0;
            padding: 0;
            -webkit-overflow-scrolling: touch;
            transition: background 0.2s ease;
        }
        .neon-text { 
            text-shadow: 0 0 5px #9900ff, 0 0 10px #9900ff, 0 0 20px #9900ff; 
            animation: glitch 0.5s linear infinite; 
            word-break: break-all;
        }
        .neon-button { 
            background: #9900ff; 
            border: 3px solid #9900ff; 
            color: #ffffff; 
            padding: 12px 24px; 
            border-radius: 8px; 
            transition: all 0.3s ease; 
        }
        .neon-button:hover { 
            box-shadow: 0 0 20px #9900ff, 0 0 40px #9900ff; 
            background: #333333; 
            color: #9900ff; 
        }
        .code-block { 
            background: #1a1a1a; 
            border: 3px solid #9900ff; 
            padding: 25px; 
            border-radius: 12px; 
            max-height: 600px; 
            overflow-y: auto; 
            box-shadow: 0 0 30px rgba(153, 0, 255, 0.4); 
        }
        .parallax { 
            background-position: center; 
            background-size: cover; 
            background-color: #1a1a1a; /* Fallback for broken image */
            min-height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom));
            padding: env(safe-area-inset-top) 10px env(safe-area-inset-bottom);
        }
        .neural-orb { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: 0; /* Raised z-index to ensure visibility */
            opacity: 0.6; /* Adjusted for visibility */
            pointer-events: none; /* Prevent interaction blocking */
        }
        .lightning-canvas { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: -2; 
            opacity: 0.8; 
        }
        .shockwave-canvas { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: -3; 
            opacity: 0.5; 
        }
        .ascii-rain { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: -4; 
            opacity: 0.3; 
        }
        .neural-matrix { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: -5; 
            opacity: 0.2; 
        }
        .neon-pulse { 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: -6; 
            opacity: 0.4; 
        }
        .hud-overlay { 
            position: fixed; 
            top: env(safe-area-inset-top, 20px); 
            right: 20px; 
            width: 250px; 
            height: 120px; 
            z-index: 10; /* Increased for visibility */
            opacity: 0.9; 
            background: rgba(26, 26, 26, 0.7); 
            border: 2px solid #9900ff;
            border-radius: 8px;
        }
        .triad-glyph { 
            position: fixed; 
            bottom: env(safe-area-inset-bottom, 20px); 
            left: 20px; 
            width: 120px; 
            height: 120px; 
            z-index: 10; 
            opacity: 0.9; 
            background: rgba(26, 26, 26, 0.7); 
            border: 2px solid #ffff00;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .cyber-dick { 
            position: fixed; 
            font-size: 12px; 
            font-family: monospace; 
            color: #9900ff; 
            text-shadow: 0 0 5px #ffff00; 
            opacity: 0; 
            transition: opacity 0.2s ease; 
            pointer-events: none; /* Prevent interaction */
        }
        .puzzle-input { 
            background: #1a1a1a; 
            border: 3px solid #9900ff; 
            padding: 12px; 
            color: #ffffff; 
            border-radius: 8px;
        }
        .hint { 
            color: #ffffff; 
            font-size: 1.2em; 
            text-shadow: none;
            padding: 5px;
            background: rgba(0, 0, 0, 0.7); 
        }
        .hint.lightning-flash { 
            text-shadow: 0 0 5px #ffff00; 
        }
        .feature-card { 
            transition: transform 0.3s ease, box-shadow 0.3s ease; 
        }
        .feature-card:hover { 
            transform: scale(1.1); 
            box-shadow: 0 0 30px #9900ff; 
        }
        .lightning-flash { 
            text-shadow: 0 0 10px #ffff00 !important; 
            transition: text-shadow 0.1s ease; 
        }
        @keyframes glitch {
            0%, 100% { transform: translate(0); }
            10%, 30%, 50%, 70%, 90% { transform: translate(-3px, 3px) skew(3deg); }
            20%, 40%, 60%, 80% { transform: translate(3px, -3px) skew(-3deg); }
        }
        @keyframes pulse-bg {
            0% { background: linear-gradient(45deg, #666666, #999999); }
            50% { background: linear-gradient(45deg, #666666, #aaaaaa); }
            100% { background: linear-gradient(45deg, #666666, #999999); }
        }
        @keyframes orb-pulse {
            0% { box-shadow: 0 0 10px #9900ff, 0 0 20px #9900ff; }
            50% { box-shadow: 0 0 20px #ffff00, 0 0 40px #ffff00; }
            100% { box-shadow: 0 0 10px #9900ff, 0 0 20px #9900ff; }
        }
        @keyframes screen-shake {
            0% { transform: translate(0, 0); }
            25% { transform: translate(-5px, 5px); }
            50% { transform: translate(5px, -5px); }
            75% { transform: translate(-3px, 3px); }
            100% { transform: translate(0, 0); }
        }
        @media only screen and (max-width: 430px) {
            h1 { font-size: 2.5rem; line-height: 1.1; }
            p.text-3xl { font-size: 1.25rem; }
            .neon-button { padding: 8px 16px; font-size: 0.9rem; }
            .code-block { padding: 15px; max-height: 400px; }
            .hud-overlay { width: 150px; height: 80px; top: env(safe-area-inset-top, 10px); right: 10px; }
            .triad-glyph { width: 80px; height: 80px; bottom: env(safe-area-inset-bottom, 10px); left: 10px; }
            .feature-card { padding: 12px; }
            .parallax { min-height: calc(100vh - env(safe-area-inset-top) - env(safe-area-inset-bottom)); padding: env(safe-area-inset-top) 5px env(safe-area-inset-bottom); }
            canvas { transform: scale(0.9); }
        }
    </style>
</head>
<body>
    <!-- HTML structure unchanged, only scripts modified -->
    <nav class="bg-gray-800 p-4 fixed top-0 w-full z-10">
        <ul class="flex space-x-6 justify-center text-white text-xl">
            <li><a href="information.html" class="neon-text hover:text-yellow-300">Information</a></li>
            <li><a href="team.html" class="neon-text hover:text-yellow-300">Team</a></li>
            <li><a href="donate.html" class="neon-text hover:text-yellow-300">Donate</a></li>
            <li><a href="contact-us.html" class="neon-text hover:text-yellow-300">Contact Us</a></li>
        </ul>
    </nav>

    <canvas id="lightning-canvas" class="lightning-canvas"></canvas>
    <canvas id="shockwave-canvas" class="shockwave-canvas"></canvas>
    <canvas id="ascii-rain" class="ascii-rain"></canvas>
    <canvas id="neural-matrix" class="neural-matrix"></canvas>
    <canvas id="neon-pulse" class="neon-pulse"></canvas>
    <canvas id="hud-overlay" class="hud-overlay"></canvas>
    <canvas id="triad-glyph" class="triad-glyph">
        <p class="text-white text-center text-lg">Triad Sync: 75%</p>
    </canvas>
    <div id="cyber-dicks"></div>

    <section class="parallax flex items-center justify-center mt-16">
        <div class="text-center">
            <h1 class="text-8xl neon-text">HyperChaoticNeuralCodec</h1>
            <p class="text-3xl text-white mt-4">Neon-Yellow Lightning-Fucked XAI Chaos</p>
        </div>
    </section>

    <div id="neural-orb" class="neural-orb"></div>

    <main class="p-10 max-w-7xl mx-auto relative mt-16">
        <section class="mb-16">
            <h2 class="text-4xl neon-text mb-6">Crack This Cipher, You Unhinged Motherfucker</h2>
            <p class="text-white mb-6">Decode this to find the single-digit key (1-9, no bullshit):</p>
            <p class="text-neon-text mb-6 cipher-text">“Ixpvgu xli kwwl jkyf ymj: 7”</p>
            <input type="text" id="key-input" class="puzzle-input mb-6" placeholder="Enter the key (1 digit, asshole)">
            <button class="neon-button" onclick="checkKey()">Unlock the Fucking Chaos</button>
            <div id="hint-container" class="mt-6">
                <p class="hint" id="hint-0">Hint (0s): Prime number between 5-10.</p>
                <p class="hint" id="hint-20" style="display: none;">Hint (20s): Two hands minus three, asshole.</p>
                <p class="hint" id="hint-40" style="display: none;">Hint (40s): Mendeleev’s lucky number, dipshit.</p>
            </div>
            <div id="code-container" style="display: none;">
                <button class="neon-button mb-6" onclick="copyCode('hnfc-code')">Copy This Fucking Code</button>
                <pre class="code-block"><code id="hnfc-code" class="language-python">
                    <!-- Python code unchanged -->
                    <!-- [Insert original Python code here] -->
                </code></pre>
            </div>
        </section>

        <section class="mb-16 grid grid-cols-1 md:grid-cols-3 gap-10">
            <div class="p-8 bg-gray-800 rounded-lg feature-card">
                <h3 class="text-2xl neon-text mb-4">TriadSynapse NAS</h3>
                <p class="text-white">Three chaotic forces unite like Neuralink’s BCI, forming a super-intelligent core.</p>
            </div>
            <div class="p-8 bg-gray-800 rounded-lg feature-card">
                <h3 class="text-2xl neon-text mb-4">Multi-Modal Fusion</h3>
                <p class="text-white">Fuses text, image, audio like XAI’s SPARK-driven transparent models.</p>
            </div>
            <div class="p-8 bg-gray-800 rounded-lg feature-card">
                <h3 class="text-2xl neon-text mb-4">Distributed Computing</h3>
                <p class="text-white">Scales like SpaceX’s Thunder clusters, ready for cosmic chaos.</p>
            </div>
        </section>

        <section class="text-center mb-16">
            <a href="https://github.com/yourusername/repo" class="neon-button">Join the Fucking Chaos</a>
        </section>
    </main>

    <footer class="p-6 text-center bg-gray-800">
        <p class="text-white text-lg">© 2025 HNFC Team - Powered by SPARK, Motherfuckers</p>
        <ul class="flex justify-center space-x-6 mt-2 text-white text-lg">
            <li><a href="information.html" class="hover:text-yellow-300">Info</a></li>
            <li><a href="team.html" class="hover:text-yellow-300">Team</a></li>
            <li><a href="donate.html" class="hover:text-yellow-300">Donate</a></li>
            <li><a href="contact-us.html" class="hover:text-yellow-300">Contact</a></li>
        </ul>
    </footer>

    <script>
        // Consolidated animation state
        const state = {
            stormMode: false,
            shockwaveRadius: 0,
            pulseRadius: 0,
            lastFrameTime: performance.now()
        };

        // Initialize canvases
        const canvases = {
            lightning: { id: 'lightning-canvas', ctx: null, width: window.innerWidth, height: window.innerHeight },
            shockwave: { id: 'shockwave-canvas', ctx: null, width: window.innerWidth, height: window.innerHeight },
            ascii: { id: 'ascii-rain', ctx: null, width: window.innerWidth, height: window.innerHeight },
            matrix: { id: 'neural-matrix', ctx: null, width: window.innerWidth, height: window.innerHeight },
            pulse: { id: 'neon-pulse', ctx: null, width: window.innerWidth, height: window.innerHeight },
            hud: { id: 'hud-overlay', ctx: null, width: window.innerWidth < 430 ? 150 : 250, height: window.innerWidth < 430 ? 80 : 120 },
            glyph: { id: 'triad-glyph', ctx: null, width: window.innerWidth < 430 ? 80 : 120, height: window.innerWidth < 430 ? 80 : 120 },
            neural: { id: null, ctx: null, width: window.innerWidth, height: window.innerHeight }
        };

        // Initialize canvas contexts
        Object.values(canvases).forEach(canvas => {
            if (canvas.id) {
                const el = document.getElementById(canvas.id);
                canvas.ctx = el.getContext('2d');
                el.width = canvas.width;
                el.height = canvas.height;
            }
        });

        // Neural net canvas
        const neuralCanvas = document.createElement('canvas');
        neuralCanvas.style.position = 'absolute';
        neuralCanvas.style.top = '0';
        neuralCanvas.style.left = '0';
        neuralCanvas.style.width = '100%';
        neuralCanvas.style.height = '100%';
        neuralCanvas.style.zIndex = '-1';
        neuralCanvas.style.opacity = '0.4';
        document.querySelector('main').appendChild(neuralCanvas);
        canvases.neural.ctx = neuralCanvas.getContext('2d');
        neuralCanvas.width = canvases.neural.width;
        neuralCanvas.height = canvases.neural.height;

        // Puzzle logic
        window.onload = () => {
            alert('3 hints over 60 seconds, crack the cipher or you don’t deserve the code, fucker!');
            document.getElementById('hint-0').style.display = 'block';
            setTimeout(() => document.getElementById('hint-20').style.display = 'block', 20000);
            setTimeout(() => document.getElementById('hint-40').style.display = 'block', 40000);
        };

        function checkKey() {
            const key = document.getElementById('key-input').value;
            if (key === '7') {
                document.getElementById('code-container').style.display = 'block';
                alert('You cracked the chaos, you unhinged fuck!');
            } else {
                alert('Wrong fucking key. It’s one digit. Get it together.');
            }
        }

        function copyCode(id) {
            const code = document.getElementById(id).textContent;
            navigator.clipboard.writeText(code).then(() => alert('Code’s yours, you chaotic motherfucker!'));
        }

        // Lightning
        function drawLightning() {
            const { ctx, width, height } = canvases.lightning;
            const lightningChance = state.stormMode ? 0.2 : 0.1;
            if (Math.random() < lightningChance) {
                ctx.clearRect(0, 0, width, height);
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 6;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#9900ff';
                ctx.beginPath();
                let x = Math.random() * width;
                let y = 0;
                ctx.moveTo(x, y);
                for (let i = 0; i < 8; i++) {
                    x += (Math.random() - 0.5) * 150;
                    y += height / 8;
                    ctx.lineTo(x, y);
                    if (Math.random() < 0.4) {
                        let forkX = x;
                        let forkY = y;
                        ctx.moveTo(forkX, forkY);
                        for (let j = 0; j < 5; j++) {
                            forkX += (Math.random() - 0.5) * 100;
                            forkY += height / 16;
                            ctx.lineTo(forkX, forkY);
                        }
                    }
                }
                ctx.stroke();
                document.body.style.background = 'linear-gradient(45deg, #9900ff, #ffff00)';
                document.body.style.opacity = '0.8';
                document.body.style.animation = 'screen-shake 0.2s';
                document.querySelectorAll('.neon-text, .text-white, .hint').forEach(el => el.classList.add('lightning-flash'));
                setTimeout(() => {
                    ctx.globalAlpha = 0.4;
                    ctx.stroke();
                    setTimeout(() => {
                        ctx.clearRect(0, 0, width, height);
                        ctx.globalAlpha = 1;
                        document.body.style.background = 'linear-gradient(45deg, #666666, #999999)';
                        document.body.style.opacity = '1';
                        document.body.style.animation = '';
                        document.querySelectorAll('.lightning-flash').forEach(el => el.classList.remove('lightning-flash'));
                    }, 200);
                }, 100);
            }
        }

        // Shockwave
        function drawShockwave() {
            const { ctx, width, height } = canvases.shockwave;
            if (Math.random() < 0.1 || state.stormMode) {
                state.shockwaveRadius = 10;
                setTimeout(() => state.shockwaveRadius = 0, 500);
            }
            if (state.shockwaveRadius > 0) {
                ctx.clearRect(0, 0, width, height);
                ctx.beginPath();
                ctx.arc(width / 2, height / 2, state.shockwaveRadius, 0, Math.PI * 2);
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 3;
                ctx.globalAlpha = 0.5;
                ctx.stroke();
                state.shockwaveRadius += 10;
                if (state.shockwaveRadius > Math.max(width, height)) state.shockwaveRadius = 0; // Prevent infinite growth
            }
        }

        // Neon Pulse
        function drawNeonPulse() {
            const { ctx, width, height } = canvases.pulse;
            if (state.stormMode || state.shockwaveRadius > 0) {
                state.pulseRadius = 10;
                setTimeout(() => state.pulseRadius = 0, 500);
            }
            if (state.pulseRadius > 0) {
                ctx.clearRect(0, 0, width, height);
                ctx.beginPath();
                ctx.arc(width / 2, height / 2, state.pulseRadius, 0, Math.PI * 2);
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 5;
                ctx.globalAlpha = 0.7;
                ctx.stroke();
                state.pulseRadius += 15;
                if (state.pulseRadius > Math.max(width, height)) state.pulseRadius = 0; // Prevent infinite growth
            }
        }

        // ASCII Rain
        const asciiChars = ['∆', '⚡', '*', '8==D', '∆∆∆', 'XAI', 'SPARK'];
        const drops = Array.from({ length: window.innerWidth < 430 ? 30 : 50 }, () => ({
            x: Math.random() * canvases.ascii.width,
            y: Math.random() * canvases.ascii.height,
            char: asciiChars[Math.floor(Math.random() * asciiChars.length)],
            speed: Math.random() * 5 + 2
        }));
        function drawAsciiRain() {
            const { ctx, width, height } = canvases.ascii;
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = '#9900ff';
            ctx.font = window.innerWidth < 430 ? '10px monospace' : '12px monospace';
            drops.forEach(drop => {
                ctx.fillText(drop.char, drop.x, drop.y);
                drop.y += drop.speed;
                if (drop.y > height) {
                    drop.y = 0;
                    drop.char = asciiChars[Math.floor(Math.random() * asciiChars.length)];
                }
                if ((state.shockwaveRadius > 0 || state.stormMode) && (drop.char === '∆∆∆' || drop.char === '8==D')) {
                    drop.char = 'XAI';
                    drop.speed += 5;
                    for (let i = 0; i < 5; i++) {
                        let sparkX = drop.x + (Math.random() - 0.5) * 20;
                        let sparkY = drop.y + (Math.random() - 0.5) * 20;
                        ctx.fillText('⚡', sparkX, sparkY);
                    }
                    setTimeout(() => {
                        drop.char = asciiChars[Math.floor(Math.random() * asciiChars.length)];
                        drop.speed = Math.random() * 5 + 2;
                    }, 200);
                }
            });
        }

        // Neural Matrix
        function drawMatrixGrid() {
            const { ctx, width, height } = canvases.matrix;
            ctx.clearRect(0, 0, width, height);
            ctx.strokeStyle = '#9900ff';
            ctx.lineWidth = 1;
            const gridSize = window.innerWidth < 430 ? 30 : 50;
            for (let x = 0; x < width; x += gridSize) {
                for (let y = 0; y < height; y += gridSize) {
                    ctx.beginPath();
                    ctx.arc(x, y, 5 + Math.sin(Date.now() * 0.002 + (state.pulseRadius > 0 ? state.pulseRadius * 0.01 : 0)) * 2, 0, Math.PI * 2);
                    ctx.stroke();
                    if (Math.random() < 0.05 || state.pulseRadius > 0) {
                        ctx.lineTo(x + Math.random() * gridSize, y + Math.random() * gridSize);
                        ctx.stroke();
                    }
                }
            }
        }

        // Holographic HUD
        function drawHUD() {
            const { ctx, width, height } = canvases.hud;
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = '#ffffff';
            ctx.font = window.innerWidth < 430 ? '10px monospace' : '12px monospace';
            ctx.fillText(`BCI SYNC: ${Math.floor(Math.random() * 100)}%`, 10, 20);
            ctx.fillText(`NEURAL LOAD: ${Math.random().toFixed(2)} THz`, 10, 40);
            ctx.fillText(`CHAOS METER: ${(state.stormMode || state.shockwaveRadius > 0) ? 100 : Math.floor(Math.random() * 100)}%`, 10, 60);
            ctx.beginPath();
            const barWidth = width - 20;
            ctx.rect(10, 70, barWidth * ((state.stormMode || state.shockwaveRadius > 0) ? 1 : Math.random() * 0.5 + 0.5), 10);
            ctx.fillStyle = state.shockwaveRadius > 0 ? '#ffff00' : '#9900ff';
            ctx.fill();
            ctx.stroke();
            if (Math.random() < 0.1 || state.stormMode) {
                ctx.globalAlpha = 0.6;
                ctx.fillStyle = '#ffff00';
                ctx.fillRect(0, 0, width, height);
                ctx.globalAlpha = 1;
            }
        }
        canvases.hud.el = document.getElementById('hud-overlay');
        canvases.hud.el.addEventListener('touchstart', () => {
            canvases.hud.el.style.transform = 'scale(1.1)';
            setTimeout(() => canvases.hud.el.style.transform = 'scale(1)', 200);
        });

        // TriadSynapse Glyph
        function drawGlyph() {
            const { ctx, width, height } = canvases.glyph;
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = '#ffffff';
            ctx.font = window.innerWidth < 430 ? '10px monospace' : '12px monospace';
            ctx.fillText(`Triad Sync: 75%`, width / 4, height / 2);
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 3;
            ctx.beginPath();
            const offset = Math.sin(Date.now() * (state.stormMode ? 0.006 : 0.003)) * 7;
            ctx.moveTo(width / 2, 20 + offset);
            ctx.lineTo(width / 2 + 30 + offset, height - 30);
            ctx.lineTo(width / 2 - 30 - offset, height - 30);
            ctx.closePath();
            ctx.stroke();
            if (state.stormMode || state.shockwaveRadius > 0) {
                ctx.beginPath();
                ctx.arc(width / 2, height / 2, 40, 0, Math.PI * 2);
                ctx.strokeStyle = '#ffff00';
                ctx.globalAlpha = 0.5;
                ctx.stroke();
                ctx.globalAlpha = 1;
                ctx.fillStyle = '#9900ff';
                for (let i = 0; i < 5; i++) {
                    ctx.fillRect(Math.random() * width, Math.random() * height, 3, 3);
                }
            }
        }
        canvases.glyph.el = document.getElementById('triad-glyph');
        canvases.glyph.el.addEventListener('touchstart', () => {
            canvases.glyph.el.style.transform = 'scale(1.2)';
            setTimeout(() => canvases.glyph.el.style.transform = 'scale(1)', 200);
        });

        // Cyber-Dick Swarm
        const cyberDicks = document.getElementById('cyber-dicks');
        let dickCount = 0;
        const maxDicks = 50; // Limit to prevent DOM bloat
        function addCyberDick() {
            if (dickCount >= maxDicks) return;
            let count = (state.stormMode || state.shockwaveRadius > 0) ? 3 : 1; // Reduced count for performance
            for (let i = 0; i < count; i++) {
                if (dickCount >= maxDicks) break;
                const dick = document.createElement('div');
                dick.className = 'cyber-dick';
                dick.textContent = '8==D';
                const posX = Math.random() * (window.innerWidth - 50);
                const posY = Math.random() * (window.innerHeight - 50);
                if (state.stormMode && count > 1) {
                    const offset = i * 20 - (count - 1) * 10;
                    dick.style.left = `${window.innerWidth / 2 + offset}px`;
                    dick.style.top = `${window.innerHeight / 2 + offset * 0.5}px`;
                } else {
                    dick.style.left = `${posX}px`;
                    dick.style.top = `${posY}px`;
                }
                cyberDicks.appendChild(dick);
                dickCount++;
                dick.style.opacity = '1';
                setTimeout(() => {
                    dick.style.opacity = '0';
                    setTimeout(() => {
                        dick.remove();
                        dickCount--;
                    }, 200);
                }, 300);
            }
        }

        // Neural Orb with Three.js
        let scene, camera, renderer, orb, triadNodes, superNode, particles;
        function initNeuralOrb() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0); // Transparent background
            document.getElementById('neural-orb').appendChild(renderer.domElement);
            
            const orbGeometry = new THREE.SphereGeometry(3, 32, 32);
            const orbMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x9900ff, 
                emissive: 0x9900ff, 
                emissiveIntensity: 0.5, 
                wireframe: true 
            });
            orb = new THREE.Mesh(orbGeometry, orbMaterial);
            scene.add(orb);

            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffff00, 1, 100);
            pointLight.position.set(0, 0, 10);
            scene.add(pointLight);

            triadNodes = [
                new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16), new THREE.MeshPhongMaterial({ color: 0xff3333, emissive: 0xff3333 })),
                new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16), new THREE.MeshPhongMaterial({ color: 0xff3333, emissive: 0xff3333 })),
                new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16), new THREE.MeshPhongMaterial({ color: 0xff3333, emissive: 0xff3333 }))
            ];
            triadNodes[0].position.set(4, 4, 0);
            triadNodes[1].position.set(-4, 4, 0);
            triadNodes[2].position.set(0, -4, 0);
            triadNodes.forEach(node => scene.add(node));

            superNode = new THREE.Mesh(new THREE.SphereGeometry(0.8, 16, 16), new THREE.MeshPhongMaterial({ color: 0xffff00, emissive: 0xffff00 }));
            superNode.position.set(0, 0, 0);
            scene.add(superNode);

            const particleCount = window.innerWidth < 430 ? 500 : 1000; // Reduced for performance
            particles = new THREE.Points(
                new THREE.BufferGeometry().setFromPoints(
                    Array.from({ length: particleCount }, () => new THREE.Vector3(
                        Math.random() * 15 - 7.5, Math.random() * 15 - 7.5, Math.random() * 15 - 7.5
                    ))
                ),
                new THREE.PointsMaterial({ color: 0xff3333, size: window.innerWidth < 430 ? 0.05 : 0.1, blending: THREE.AdditiveBlending })
            );
            scene.add(particles);
            camera.position.z = 8;
        }

        let orbPulse = 1;
        function animateNeuralOrb() {
            orb.rotation.z += 0.005;
            orbPulse = Math.sin(Date.now() * 0.01) * 0.3 + 1;
            orb.scale.set(orbPulse, orbPulse, orbPulse);
            particles.rotation.z += 0.003;
            if (Math.random() < 0.1 || state.stormMode) { // Reduced frequency
                particles.geometry.attributes.position.array.forEach((_, i) => {
                    if (i % 3 === 0) {
                        particles.geometry.attributes.position.array[i] += (Math.random() - 0.5) * 0.7;
                        particles.geometry.attributes.position.array[i + 1] += (Math.random() - 0.5) * 0.7;
                    }
                });
                particles.geometry.attributes.position.needsUpdate = true;
            }
            renderer.render(scene, camera);
        }

        document.addEventListener('mousemove', (e) => {
            if (orb) {
                orb.rotation.x = e.clientY * 0.002;
                orb.rotation.y = e.clientX * 0.002;
                triadNodes.forEach((node, i) => {
                    const t = Date.now() * 0.003 + i;
                    node.position.x = Math.sin(t) * 5;
                    node.position.y = Math.cos(t) * 5;
                    if (Math.random() < 0.1 || state.stormMode) {
                        node.material.emissive.set(0xffff00);
                        setTimeout(() => node.material.emissive.set(0xff3333), 300);
                    }
                });
            }
        });

        document.addEventListener('touchmove', (e) => {
            const touch = e.touches[0];
            if (orb) {
                orb.rotation.x = touch.clientY * 0.002;
                orb.rotation.y = touch.clientX * 0.002;
                orb.style.transform = 'scale(1.1)';
                setTimeout(() => orb.style.transform = 'scale(1)', 200);
            }
        });

        // Neural Net
        function drawNeuralNet() {
            const { ctx, width, height } = canvases.neural;
            ctx.clearRect(0, 0, width, height);
            ctx.strokeStyle = `rgba(153, 0, 255, ${Math.min(1, window.scrollY / 500)})`;
            ctx.lineWidth = 3;
            const nodeCount = window.innerWidth < 430 ? 4 : 6;
            for (let i = 0; i < nodeCount; i++) {
                ctx.beginPath();
                ctx.arc(100 + i * (width / nodeCount), 200 + Math.sin(Date.now() * 0.002) * 40, 12, 0, Math.PI * 2);
                ctx.stroke();
                if (i < nodeCount - 1) {
                    ctx.moveTo(100 + i * (width / nodeCount), 200 + Math.sin(Date.now() * 0.002) * 40);
                    ctx.lineTo(100 + (i + 1) * (width / nodeCount), 200 + Math.sin(Date.now() * 0.002) * 40);
                    ctx.stroke();
                }
                if (state.stormMode) {
                    ctx.beginPath();
                    ctx.arc(100 + i * (width / nodeCount), 200, 5, 0, Math.PI * 2);
                    ctx.fillStyle = '#ffff00';
                    ctx.fill();
                }
            }
        }

        // Glitchy Text
        function glitchText() {
            if (Math.random() < (window.innerWidth < 430 ? 0.1 : 0.15)) { // Reduced frequency
                const textElements = document.querySelectorAll('.neon-text');
                textElements.forEach(el => {
                    const original = el.textContent;
                    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789∆⚡XAI';
                    let glitched = '';
                    for (let char of original) {
                        if (Math.random() < 0.3 && char !== ' ') glitched += chars[Math.floor(Math.random() * chars.length)];
                        else glitched += char;
                    }
                    el.textContent = glitched;
                    el.style.textShadow = '0 0 10px #ffff00';
                    setTimeout(() => {
                        el.textContent = original;
                        el.style.textShadow = '0 0 5px #9900ff, 0 0 10px #9900ff, 0 0 20px #9900ff';
                    }, 150);
                });
            }
        }

        // Storm Mode
        function updateStormMode() {
            if (Math.random() < 0.01) {
                state.stormMode = true;
                document.body.style.background = 'linear-gradient(45deg, #ff3333, #ffff00)';
                setTimeout(() => {
                    state.stormMode = false;
                    document.body.style.background = 'linear-gradient(45deg, #666666, #999999)';
                }, 3000);
            }
        }

        // Consolidated Animation Loop
        function animate() {
            const now = performance.now();
            if (now - state.lastFrameTime < 16) { // Cap at ~60fps
                requestAnimationFrame(animate);
                return;
            }
            state.lastFrameTime = now;

            drawLightning();
            drawShockwave();
            drawNeonPulse();
            drawAsciiRain();
            drawMatrixGrid();
            drawHUD();
            drawGlyph();
            drawNeuralNet();
            glitchText();
            addCyberDick();
            animateNeuralOrb();

            requestAnimationFrame(animate);
        }

        // Resize Handler
        function resizeCanvases() {
            canvases.lightning.width = window.innerWidth;
            canvases.lightning.height = window.innerHeight;
            canvases.shockwave.width = window.innerWidth;
            canvases.shockwave.height = window.innerHeight;
            canvases.ascii.width = window.innerWidth;
            canvases.ascii.height = window.innerHeight;
            canvases.matrix.width = window.innerWidth;
            canvases.matrix.height = window.innerHeight;
            canvases.pulse.width = window.innerWidth;
            canvases.pulse.height = window.innerHeight;
            canvases.hud.width = window.innerWidth < 430 ? 150 : 250;
            canvases.hud.height = window.innerWidth < 430 ? 80 : 120;
            canvases.glyph.width = window.innerWidth < 430 ? 80 : 120;
            canvases.glyph.height = window.innerWidth < 430 ? 80 : 120;
            canvases.neural.width = window.innerWidth;
            canvases.neural.height = window.innerHeight;

            Object.values(canvases).forEach(canvas => {
                if (canvas.el) {
                    canvas.el.width = canvas.width;
                    canvas.el.height = canvas.height;
                }
            });
            neuralCanvas.width = canvases.neural.width;
            neuralCanvas.height = canvases.neural.height;
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            drops.forEach(drop => {
                drop.x = Math.min(drop.x, window.innerWidth);
                drop.y = Math.min(drop.y, window.innerHeight);
            });
        }

        window.addEventListener('resize', resizeCanvases);

        // Initialize and start
        try {
            initNeuralOrb();
            resizeCanvases();
            animate();
            setInterval(updateStormMode, 5000);
        } catch (e) {
            console.error('Initialization error:', e);
        }
    </script>
</body>
</html>
