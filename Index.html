<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="HyperChaoticNeuralCodec: A neon-charged XAI dream for Neuralink chaos.">
    <meta name="keywords" content="XAI, Neuralink, chaos, BCI, Python, TriadSynapse, SPARK">
    <title>HyperChaoticNeuralCodec - Unleashed Chaos</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-python.min.js"></script>
    <style>
        body {
            background: linear-gradient(45deg, #2a2a2a, #4a4a4a);
            color: #ffffff;
            font-family: 'Courier New', monospace;
            overflow-x: hidden;
            position: relative;
            animation: pulse-bg 10s infinite ease-in-out;
        }
        .neon-text {
            text-shadow: 0 0 5px #ff00ff, 0 0 15px #ff00ff, 0 0 25px #ff00ff, 0 0 50px #ff00ff;
            animation: glitch 0.3s linear infinite alternate;
            letter-spacing: 2px;
        }
        .neon-button {
            background: transparent;
            border: 3px solid #ff00ff;
            color: #ff00ff;
            padding: 12px 24px;
            border-radius: 8px;
            transition: all 0.3s ease;
            font-weight: bold;
            text-transform: uppercase;
        }
        .neon-button:hover {
            background: #ff00ff;
            color: #000000;
            box-shadow: 0 0 20px #ff00ff, 0 0 40px #ff00ff;
        }
        .code-block {
            background: #1a1a1a;
            border: 3px solid #ff00ff;
            padding: 25px;
            border-radius: 12px;
            max-height: 600px;
            overflow-y: auto;
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.5);
        }
        .parallax {
            background-attachment: fixed;
            background-position: center;
            background-size: cover;
            background-image: url('https://example.com/cyberpunk-dark-bg.jpg');
        }
        .neural-orb {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            z-index: -1;
            opacity: 0.7;
        }
        .lightning-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            opacity: 0.9;
        }
        .shockwave-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -3;
            opacity: 0.6;
        }
        .ascii-rain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -4;
            opacity: 0.4;
        }
        .hud-overlay {
            position: fixed;
            top: 20px;
            right: 20px;
           gaben
            width: 250px;
            height: 120px;
            z-index: 1;
            opacity: 0.7;
        }
        .triad-glyph {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            z-index: 1;
            opacity: 0.9;
        }
        .cyber-dick {
            position: fixed;
            font-size: 14px;
            font-family: monospace;
            color: #ff00ff;
            text-shadow: 0 0 5px #ffff00;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .puzzle-input {
            background: #1a1a1a;
            border: 3px solid #ff00ff;
            padding: 12px;
            color: #ffffff;
            border-radius: 8px;
        }
        .hint {
            color: #ff00ff;
            font-size: 1.1em;
            text-shadow: 0 0 5px #ff00ff;
        }
        .feature-card {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            background: rgba(26, 26, 26, 0.9);
            border: 2px solid #ff00ff;
        }
        .feature-card:hover {
            transform: scale(1.05) rotate(2deg);
            box-shadow: 0 0 40px #ff00ff, 0 0 80px #ff00ff;
        }
        .lightning-flash {
            text-shadow: 0 0 15px #ffff00 !important;
            animation: lightning-pulse 0.2s ease;
        }
        .navbar {
            position: sticky;
            top: 0;
            z-index: 100;
            background: rgba(26, 26, 26, 0.95);
            border-bottom: 2px solid #ff00ff;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
        }
        .nav-tab {
            color: #ff00ff;
            font-weight: bold;
            text-transform: uppercase;
            padding: 12px 20px;
            transition: all 0.3s ease;
        }
        .nav-tab:hover, .nav-tab.active {
            background: #ff00ff;
            color: #000000;
            box-shadow: 0 0 15px #ff00ff;
        }
        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px) skew(2deg); }
            40% { transform: translate(2px, -2px) skew(-2deg); }
            60% { transform: translate(-2px, 0) skew(0); }
            80% { transform: translate(2px, 0) skew(0); }
            100% { transform: translate(0); }
        }
        @keyframes pulse-bg {
            0% { background: linear-gradient(45deg, #2a2a2a, #4a4a4a); }
            50% { background: linear-gradient(45deg, #2a2a2a, #6a6a6a); }
            100% { background: linear-gradient(45deg, #2a2a2a, #4a4a4a); }
        }
        @keyframes lightning-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="navbar">
        <div class="max-w-7xl mx-auto px-4">
            <ul class="flex justify-center space-x-4">
                <li><a href="#project-info" class="nav-tab active" onclick="switchTab('project-info')">Project Info</a></li>
                <li><a href="#team" class="nav-tab" onclick="switchTab('team')">Team</a></li>
                <li><a href="#invest" class="nav-tab" onclick="switchTab('invest')">Invest</a></li>
                <li><a href="#contact" class="nav-tab" onclick="switchTab('contact')">Contact Us</a></li>
            </ul>
        </div>
    </nav>

    <!-- Canvases -->
    <canvas id="lightning-canvas" class="lightning-canvas"></canvas>
    <canvas id="shockwave-canvas" class="shockwave-canvas"></canvas>
    <canvas id="ascii-rain" class="ascii-rain"></canvas>
    <canvas id="hud-overlay" class="hud-overlay"></canvas>
    <canvas id="triad-glyph" class="triad-glyph"></canvas>
    <div id="cyber-dicks"></div>

    <!-- Hero -->
    <section class="h-screen flex items-center justify-center parallax">
        <div class="text-center relative z-10">
            <h1 class="text-9xl neon-text font-bold tracking-wider">HyperChaoticNeuralCodec</h1>
            <p class="text-4xl text-white mt-6 neon-text">Neon-Charged XAI Chaos Unleashed</p>
            <a href="#main-content" class="neon-button mt-8">Dive into the Chaos</a>
        </div>
        <div id="neural-orb" class="neural-orb"></div>
    </section>

    <!-- Main -->
    <main id="main-content" class="p-10 max-w-7xl mx-auto relative">
        <!-- Project Info Section -->
        <section id="project-info" class="tab-content">
            <h2 class="text-5xl neon-text mb-8 text-center">Project Information</h2>
            <p class="text-white text-lg mb-6">HyperChaoticNeuralCodec is a groundbreaking fusion of XAI and Neuralink-inspired tech, designed to harness chaotic neural patterns for next-gen BCI applications. Powered by SPARK, it’s a wild ride into the future of human-machine synergy.</p>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                <div class="p-6 bg-gray-800 rounded-lg feature-card">
                    <h3 class="text-2xl neon-text mb-4">Core Technology</h3>
                    <p class="text-white">TriadSynapse NAS, multi-modal fusion, and distributed computing drive this beast.</p>
                </div>
                <div class="p-6 bg-gray-800 rounded-lg feature-card">
                    <h3 class="text-2xl neon-text mb-4">Mission</h3>
                    <p class="text-white">To push the boundaries of chaos-driven intelligence and make BCI accessible to the masses.</p>
                </div>
            </div>
        </section>

        <!-- Team Section -->
        <section id="team" class="tab-content hidden">
            <h2 class="text-5xl neon-text mb-8 text-center">Our Team</h2>
            <p class="text-white text-lg mb-6">Meet the chaotic minds behind HyperChaoticNeuralCodec, a crew of renegade coders, neuroscientists, and visionaries.</p>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
                <div class="p-6 bg-gray-800 rounded-lg feature-card">
                    <h3 class="text-2xl neon-text mb-4">Dr. Chaos</h3>
                    <p class="text-white">Lead Neuroscientist. Master of neural storms.</p>
                </div>
                <div class="p-6 bg-gray-800 rounded-lg feature-card">
                    <h3 class="text-2xl neon-text mb-4">CodeSlinger</h3>
                    <p class="text-white">Chief Architect. Writes code faster than lightning.</p>
                </div>
                <div class="p-6 bg-gray-800 rounded-lg feature-card">
                    <h3 class="text-2xl neon-text mb-4">NeonVibe</h3>
                    <p class="text-white">UI/UX Wizard. Crafts chaos into beauty.</p>
                </div>
            </div>
        </section>

        <!-- Invest Section -->
        <section id="invest" class="tab-content hidden">
            <h2 class="text-5xl neon-text mb-8 text-center">Invest in the Chaos</h2>
            <p class="text-white text-lg mb-6">Join the revolution. Invest in the future of chaotic intelligence and BCI innovation.</p>
            <div class="text-center">
                <a href="mailto:invest@hnfc.io" class="neon-button">Get Investment Details</a>
            </div>
        </section>

        <!-- Contact Us Section -->
        <section id="contact" class="tab-content hidden">
            <h2 class="text-5xl neon-text mb-8 text-center">Contact Us</h2>
            <p class="text-white text-lg mb-6">Got questions? Want to join the chaos? Reach out to us.</p>
            <form class="max-w-lg mx-auto">
                <input type="text" placeholder="Name" class="puzzle-input w-full mb-4" />
                <input type="email" placeholder="Email" class="puzzle-input w-full mb-4" />
                <textarea placeholder="Message" class="puzzle-input w-full mb-4" rows="5"></textarea>
                <button type="submit" class="neon-button w-full">Send Message</button>
            </form>
        </section>

        <!-- Puzzle-Locked Code -->
        <section id="code" class="tab-content mt-16">
            <h2 class="text-5xl neon-text mb-8 text-center">Crack the Cipher</h2>
            <p class="text-white text-lg mb-6 text-center">Decode this to unlock the chaotic code (single-digit key, 1-9):</p>
            <p class="text-neon-text mb-6 text-center cipher-text">“Fwoslq wkh frgh zlwk nhb: 5”</p>
            <div class="text-center">
                <input type="text" id="key-input" class="puzzle-input mb-6 max-w-xs mx-auto" placeholder="Enter the key (1 digit)">
                <button class="neon-button" onclick="checkKey()">Unlock the Chaos</button>
            </div>
            <div id="hint-container" class="mt-6 text-center">
                <p class="hint" id="hint-20" style="display: none;">Hint (20s): Prime number between 1-10.</p>
                <p class="hint" id="hint-40" style="display: none;">Hint (40s): Fingers on one hand.</p>
                <p class="hint" id="hint-60" style="display: none;">Hint (60s): Carbon’s atomic number.</p>
            </div>
            <div id="code-container" class="mt-8" style="display: none;">
                <div class="text-center">
                    <button class="neon-button mb-6" onclick="copyCode('hnfc-code')">Copy the Code</button>
                </div>
                <pre class="code-block mx-auto"><code id="hnfc-code" class="language-python">
import numpy as np
import torch
import torch.nn as nn
import aiohttp
import asyncio
from bs4 import BeautifulSoup
from transformers import CLIPModel, CLIPProcessor, GPT2Tokenizer, GPT2LMHeadModel, T5Tokenizer, T5ForConditionalGeneration, Wav2Vec2Model, Wav2Vec2Processor
from torch.utils.data import Dataset, DataLoader
from torch.cuda.amp import autocast
from torch.utils.data.distributed import DistributedSampler
import torch.distributed as dist
import logging
import pandas as pd
import shap
from sklearn.cluster import KMeans
import random

# Logging setup
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Distributed process group
dist.init_process_group(backend='nccl')
rank = dist.get_rank()
world_size = dist.get_world_size()

# Dataset class
class QueryResponseDataset(Dataset):
    def __init__(self, csv_file, clip_processor, clip_model, device):
        self.data = pd.read_csv(csv_file)
        self.clip_processor = clip_processor
        self.clip_model = clip_model
        self.device = device

    def __len__(self):
        return len(self.data)

    def __getitem__(self, idx):
        query = self.data.iloc[idx]['query']
        response = self.data.iloc[idx]['response']
        query_inputs = self.clip_processor(text=query, return_tensors="pt").to(self.device)
        response_inputs = self.clip_processor(text=response, return_tensors="pt").to(self.device)
        query_emb = self.clip_model.get_text_features(**query_inputs).squeeze()
        response_emb = self.clip_model.get_text_features(**response_inputs).squeeze()
        return query_emb, response_emb

# BrainStorm compressor
class BrainStorm(nn.Module):
    def __init__(self, input_dim=512):
        super().__init__()
        self.compressor = nn.Sequential(
            nn.Linear(input_dim, 256), nn.ReLU(),
            nn.Linear(256, input_dim), nn.Tanh()
        )
        self.optimizer = torch.optim.Adam(self.compressor.parameters(), lr=0.001)

    def forward(self, data):
        return self.compressor(data)

# TriadSynapse with NAS (dick shape in comments)
class TriadSynapse(nn.Module):
    #   _____
    #  /     \
    # /_______\
    # |  ***  | 
    # |  ***  | 
    # |_______|
    def __init__(self, input_dim=512, hidden_dim=256):
        super().__init__()
        self.generator_candidates = [
            nn.Sequential(nn.Linear(input_dim, hidden_dim), nn.ReLU(), nn.Linear(hidden_dim, input_dim), nn.Sigmoid()),
            nn.Sequential(nn.Linear(input_dim, hidden_dim), nn.Tanh(), nn.Linear(hidden_dim, input_dim), nn.Sigmoid()),
            nn.Sequential(nn.Linear(input_dim, hidden_dim), nn.ReLU(), nn.Linear(hidden_dim, hidden_dim), nn.ReLU(), nn.Linear(hidden_dim, input_dim), nn.Sigmoid())
        ]
        self.generator = self.generator_candidates[0]
        self.critic = nn.Sequential(
            nn.Linear(input_dim, 64), nn.ReLU(),
            nn.Linear(64, 1), nn.Sigmoid()
        )
        self.refiner = nn.Sequential(
            nn.Linear(input_dim, hidden_dim), nn.ReLU(),
            nn.Linear(hidden_dim, input_dim), nn.Tanh()
        )
        self.adaptive_layer = nn.Linear(hidden_dim, hidden_dim)
        self.iterations = 7
        self.candidate_performances = [0.0] * len(self.generator_candidates)

    def refine(self, input_data):
        candidate_idx = random.randint(0, len(self.generator_candidates) - 1)
        self.generator = self.generator_candidates[candidate_idx]
        current = input_data.clone()
        validity = 0.0
        for _ in range(self.iterations):
            generated = self.generator(current)
            validity = self.critic(generated).mean().item()
            refined = self.refiner(generated)
            current = self.adaptive_layer(refined)
        self.candidate_performances[candidate_idx] = (self.candidate_performances[candidate_idx] + validity) / 2
        return current, validity

# NeuroCosmicNexus (dick shape in variable names)
class NeuroCosmicNexus(nn.Module):
    def __init__(self, input_dim=512):
        super().__init__()
        self.triad = TriadSynapse(input_dim)
        self.cock_noise = torch.randn(input_dim).to(torch.device("cuda" if torch.cuda.is_available() else "cpu")) * 0.01
        self.shaft_rate = 0.001
        self.head_space = torch.zeros(input_dim).to(self.device)  # Sneaky dick variable

    def sync(self, input_data):
        refined, validity = self.triad.refine(input_data)
        return refined + self.cock_noise + self.head_space, validity

    def evolve(self, feedback):
        with torch.no_grad():
            self.cock_noise += self.shaft_rate * feedback
            self.cock_noise = torch.clamp(self.cock_noise, -1, 1)
            self.head_space += self.shaft_rate * feedback * 0.5

# Multi-modal fusion
class MultiModalFusion(nn.Module):
    def __init__(self, embed_dim=512):
        super().__init__()
        self.text_proj = nn.Linear(embed_dim, embed_dim)
        self.image_proj = nn.Linear(embed_dim, embed_dim)
        self.audio_proj = nn.Linear(embed_dim, embed_dim)
        self.fusion = nn.MultiheadAttention(embed_dim, num_heads=8)

    def forward(self, text_emb, image_emb, audio_emb):
        text_proj = self.text_proj(text_emb).unsqueeze(0)
        image_proj = self.image_proj(image_emb).unsqueeze(0)
        audio_proj = self.audio_proj(audio_emb).unsqueeze(0)
        combined = torch.cat([text_proj, image_proj, audio_proj], dim=0)
        fused, _ = self.fusion(combined, combined, combined)
        return fused.mean(dim=0)

# NeoGrokCosmos (super dick from three dicks)
class NeoGrokCosmos:
    #   _____      _____      _____  
    #  /     \    /     \    /     \ 
    # /_______\  /_______\  /_______\
    # |  ***  |  |  ***  |  |  ***  | 
    # |  ***  |  |  ***  |  |  ***  | 
    # |_______|  |_______|  |_______|
    #          \  |  ***  |  /
    #           \ |  ***  | /
    #            \|_______|/
    def __init__(self, train_csv="path/to/train.csv"):
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        self.brainstorm = nn.parallel.DistributedDataParallel(BrainStorm().to(self.device), device_ids=[self.device])
        self.nexus = nn.parallel.DistributedDataParallel(NeuroCosmicNexus().to(self.device), device_ids=[self.device])
        self.clip_model = CLIPModel.from_pretrained("openai/clip-vit-base-patch32").to(self.device)
        self.clip_processor = CLIPProcessor.from_pretrained("openai/clip-vit-base-patch32")
        self.wav2vec2_model = Wav2Vec2Model.from_pretrained("facebook/wav2vec2-base-960h").to(self.device)
        self.wav2vec2_processor = Wav2Vec2Processor.from_pretrained("facebook/wav2vec2-base-960h")
        self.tokenizer = GPT2Tokenizer.from_pretrained('distilgpt2')
        self.llm = nn.parallel.DistributedDataParallel(GPT2LMHeadModel.from_pretrained('distilgpt2').to(self.device), device_ids=[self.device])
        self.t5_tokenizer = T5Tokenizer.from_pretrained('t5-small')
        self.t5_model = nn.parallel.DistributedDataParallel(T5ForConditionalGeneration.from_pretrained('t5-small').to(self.device), device_ids=[self.device])
        self.fusion_layer = MultiModalFusion().to(self.device)
        self.memory = []
        self.cache = {}
        self.losses = []
        self.critic_scores = []
        self.explanations = []
        self.query_embeddings = []
        self.query_count = 0
        self.train_dataset = QueryResponseDataset(train_csv, self.clip_processor, self.clip_model, self.device)
        self.train_sampler = DistributedSampler(self.train_dataset)
        self.train_loader = DataLoader(self.train_dataset, batch_size=32, shuffle=False, sampler=self.train_sampler)

    async def fetch_real_time_data(self, source="hackernews"):
        try:
            async with aiohttp.ClientSession() as session:
                url = "https://news.ycombinator.com/" if source == "hackernews" else "https://twitter.com/"
                async with session.get(url) as resp:
                    html = await resp.text()
                    soup = BeautifulSoup(html, 'html.parser')
                    return [item.text for item in soup.find_all('a')[:5]]
        except Exception as e:
            logger.error(f"Error fetching data: {e}")
            return []

    def apply_vibe_filter(self, text, vibe, user_id=None):
        if vibe == "witty":
            return f"{text} (with a dash of cosmic wit!)"
        return text

    async def process_query(self, query, vibe="witty", image=None, audio=None, user_id=None, num_candidates=3):
        if query in self.cache:
            return self.cache[query]
        try:
            real_time_data = await self.fetch_real_time_data()
            query_inputs = self.clip_processor(text=query, return_tensors="pt").to(self.device)
            query_embedding = self.clip_model.get_text_features(**query_inputs).squeeze()
            if image:
                image_inputs = self.clip_processor(images=image, return_tensors="pt").to(self.device)
                image_embedding = self.clip_model.get_image_features(**image_inputs).squeeze()
            else:
                image_embedding = torch.zeros(512).to(self.device)
            audio_embedding = torch.zeros(512).to(self.device)
            if audio:
                inputs = self.wav2vec2_processor(audio, return_tensors="pt", sampling_rate=16000).to(self.device)
                with autocast():
                    audio_embedding = self.wav2vec2_model(**inputs).last_hidden_state.mean(dim=1).squeeze()
            fused_embedding = self.fusion_layer(query_embedding, image_embedding, audio_embedding)
            with autocast():
                compressed = self.brainstorm(fused_embedding)
                synced, validity = self.nexus.sync(compressed)
                self.critic_scores.append(validity)
            inputs = self.tokenizer(query, return_tensors="pt").to(self.device)
            candidates = []
            for _ in range(num_candidates):
                with autocast():
                    output = self.llm.module.generate(**inputs, max_length=50, do_sample=True, top_k=50)
                    text = self.tokenizer.decode(output[0], skip_special_tokens=True)
                    candidates.append(text)
            candidate_inputs = [self.clip_processor(text=cand, return_tensors="pt").to(self.device) for cand in candidates]
            candidate_embeddings = [self.clip_model.get_text_features(**inp).squeeze() for inp in candidate_inputs]
            similarities = [torch.cosine_similarity(synced, emb, dim=0).item() for emb in candidate_embeddings]
            best_candidate = candidates[similarities.index(max(similarities))]
            result = self.apply_vibe_filter(best_candidate, vibe, user_id)
            self.query_embeddings.append(query_embedding.detach().cpu().numpy())
            self.query_count += 1
            if self.query_count % 10 == 0:
                best_idx = np.argmax(self.nexus.module.triad.candidate_performances)
                self.nexus.module.triad.generator = self.nexus.module.triad.generator_candidates[best_idx]
                logger.info(f"Selected best generator candidate: {best_idx}")
            if len(self.query_embeddings) % 100 == 0:
                self.cluster_queries()
            self.cache[query] = result
            self.memory.append((query, result))
            return result
        except Exception as e:
            logger.error(f"Error processing query: {e}")
            return "Error occurred!"

    def train_step(self, data, target):
        self.brainstorm.module.optimizer.zero_grad()
        output = self.brainstorm(data)
        loss = nn.MSELoss()(output, target)
        loss.backward()
        self.brainstorm.module.optimizer.step()
        return loss.item()

    def train_brainstorm(self, epochs=5):
        for epoch in range(epochs):
            self.train_sampler.set_epoch(epoch)
            for query_emb, response_emb in self.train_loader:
                loss = self.train_step(query_emb, response_emb)
                self.losses.append(loss)
                logger.info(f"Epoch {epoch+1}, Loss: {loss}")

    def cluster_queries(self):
        if len(self.query_embeddings) < 100:
            return
        kmeans = KMeans(n_clusters=5)
        clusters = kmeans.fit_predict(self.query_embeddings)
        logger.info(f"Cluster centers: {kmeans.cluster_centers_}")

# Run it
if __name__ == "__main__":
    cosmos = NeoGrokCosmos(train_csv="path/to/train.csv")
    query = "What’s the meaning of life?"
    result = asyncio.run(cosmos.process_query(query, vibe="witty", audio=None, image=None))
    print(result)
    cosmos.train_brainstorm(epochs=5)
                </code></pre>
            </div>
        </section>

        <!-- Features -->
        <section id="features" class="tab-content mt-16">
            <h2 class="text-5xl neon-text mb-8 text-center">Core Features</h2>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-10">
                <div class="p-8 feature-card">
                    <h3 class="text-2xl neon-text mb-4">TriadSynapse NAS</h3>
                    <p class="text-white">Three chaotic forces unite like Neuralink’s BCI, forming a super-intelligent core.</p>
                </div>
                <div class="p-8 feature-card">
                    <h3 class="text-2xl neon-text mb-4">Multi-Modal Fusion</h3>
                    <p class="text-white">Fuses text, image, audio like XAI’s SPARK-driven transparent models.</p>
                </div>
                <div class="p-8 feature-card">
                    <h3 class="text-2xl neon-text mb-4">Distributed Computing</h3>
                    <p class="text-white">Scales like SpaceX’s Thunder clusters, ready for cosmic chaos.</p>
                </div>
            </div>
        </section>

        <!-- CTA -->
        <section class="text-center mt-16">
            <a href="https://github.com/yourusername/repo" class="neon-button">Join the Chaos</a>
        </section>
    </main>

    <!-- Footer -->
    <footer class="p-6 text-center bg-gray-800 mt-16">
        <p class="text-white">© 2025 HNFC Team - Powered by SPARK</p>
    </footer>

    <!-- Scripts -->
    <script>
        // Tab Switching
        function switchTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.add('hidden'));
            document.getElementById(tabId).classList.remove('hidden');
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelector(`[href="#${tabId}"]`).classList.add('active');
        }

        // Puzzle Logic
        let startTime = Date.now();
        setTimeout(() => document.getElementById('hint-20').style.display = 'block', 20000);
        setTimeout(() => document.getElementById('hint-40').style.display = 'block', 40000);
        setTimeout(() => document.getElementById('hint-60').style.display = 'block', 60000);

        function checkKey() {
            const key = document.getElementById('key-input').value;
            if (key === '5') {
                document.getElementById('code-container').style.display = 'block';
                alert('Chaos unlocked, you absolute legend!');
            } else {
                alert('Wrong key. One digit, try again.');
            }
        }

        // Copy Code
        function copyCode(id) {
            const code = document.getElementById(id).textContent;
            navigator.clipboard.writeText(code).then(() => alert('Code copied, you chaotic genius!'));
        }

        // Lightning Flashes
        const lightningCanvas = document.getElementById('lightning-canvas');
        const lCtx = lightningCanvas.getContext('2d');
        lightningCanvas.width = window.innerWidth;
        lightningCanvas.height = window.innerHeight;
        function drawLightning() {
            if (Math.random() < 0.1) {
                lCtx.clearRect(0, 0, lightningCanvas.width, lightningCanvas.height);
                lCtx.strokeStyle = '#ffff00';
                lCtx.lineWidth = 6;
                lCtx.shadowBlur = 20;
                lCtx.shadowColor = '#ff00ff';
                lCtx.beginPath();
                let x = Math.random() * lightningCanvas.width;
                let y = 0;
                lCtx.moveTo(x, y);
                for (let i = 0; i < 8; i++) {
                    x += (Math.random() - 0.5) * 150;
                    y += lightningCanvas.height / 8;
                    lCtx.lineTo(x, y);
                    if (Math.random() < 0.4) {
                        let forkX = x;
                        let forkY = y;
                        lCtx.moveTo(forkX, forkY);
                        for (let j = 0; j < 4; j++) {
                            forkX += (Math.random() - 0.5) * 100;
                            forkY += lightningCanvas.height / 16;
                            lCtx.lineTo(forkX, forkY);
                        }
                    }
                }
                lCtx.stroke();
                document.body.style.opacity = '0.8';
                document.querySelectorAll('.neon-text, .text-white, .hint').forEach(el => el.classList.add('lightning-flash'));
                setTimeout(() => {
                    lCtx.globalAlpha = 0.4;
                    lCtx.stroke();
                    setTimeout(() => {
                        lCtx.clearRect(0, 0, lightningCanvas.width, lightningCanvas.height);
                        lCtx.globalAlpha = 1;
                        document.body.style.opacity = '1';
                        document.querySelectorAll('.lightning-flash').forEach(el => el.classList.remove('lightning-flash'));
                    }, 100);
                }, 100);
            }
        }
        setInterval(drawLightning, 100);

        // Neural Pulse Shockwave
        const shockwaveCanvas = document.getElementById('shockwave-canvas');
        const swCtx = shockwaveCanvas.getContext('2d');
        shockwaveCanvas.width = window.innerWidth;
        shockwaveCanvas.height = window.innerHeight;
        let shockwaveRadius = 0;
        function drawShockwave() {
            if (Math.random() < 0.1) {
                shockwaveRadius = 10;
                setTimeout(() => {
                    shockwaveRadius = 0;
                }, 500);
            }
            if (shockwaveRadius > 0) {
                swCtx.clearRect(0, 0, shockwaveCanvas.width, shockwaveCanvas.height);
                swCtx.beginPath();
                swCtx.arc(window.innerWidth / 2, window.innerHeight / 2, shockwaveRadius, 0, Math.PI * 2);
                swCtx.strokeStyle = '#ffff00';
                swCtx.lineWidth = 3;
                swCtx.globalAlpha = 0.5;
                swCtx.stroke();
                shockwaveRadius += 10;
            }
        }
        setInterval(drawShockwave, 50);

        // ASCII Art Rain
        const asciiCanvas = document.getElementById('ascii-rain');
        const asciiCtx = asciiCanvas.getContext('2d');
        asciiCanvas.width = window.innerWidth;
        asciiCanvas.height = window.innerHeight;
        const asciiChars = ['∆', '⚡', '*', '8==D', 'Ω', '∑'];
        const drops = [];
        for (let i = 0; i < 50; i++) {
            drops.push({ x: Math.random() * asciiCanvas.width, y: Math.random() * asciiCanvas.height, char: asciiChars[Math.floor(Math.random() * asciiChars.length)], speed: Math.random() * 5 + 2 });
        }
        function drawAsciiRain() {
            asciiCtx.clearRect(0, 0, asciiCanvas.width, asciiCanvas.height);
            asciiCtx.fillStyle = '#ff00ff';
            asciiCtx.font = '14px monospace';
            drops.forEach(drop => {
                asciiCtx.fillText(drop.char, drop.x, drop.y);
                drop.y += drop.speed;
                if (drop.y > asciiCanvas.height) {
                    drop.y = 0;
                    drop.char = asciiChars[Math.floor(Math.random() * asciiChars.length)];
                }
            });
        }
        setInterval(drawAsciiRain, 50);

        // Holographic HUD
        const hudCanvas = document.getElementById('hud-overlay');
        const hudCtx = hudCanvas.getContext('2d');
        hudCanvas.width = 250;
        hudCanvas.height = 120;
        function drawHUD() {
            hudCtx.clearRect(0, 0, hudCanvas.width, hudCanvas.height);
            hudCtx.strokeStyle = '#ff00ff';
            hudCtx.lineWidth = 1;
            hudCtx.font = '12px monospace';
            hudCtx.fillStyle = '#ff00ff';
            hudCtx.fillText(`BCI SYNC: ${Math.floor(Math.random() * 100)}%`, 10, 20);
            hudCtx.fillText(`NEURAL LOAD: ${Math.random().toFixed(2)} THz`, 10, 40);
            hudCtx.fillText(`CHAOS RATE: ${Math.floor(Math.random() * 1000)}`, 10, 60);
            hudCtx.beginPath();
            for (let i = 0; i < 12; i++) {
                hudCtx.moveTo(50 + i * 15, 100);
                hudCtx.lineTo(50 + i * 15, 100 - Math.random() * 30);
            }
            hudCtx.stroke();
            if (Math.random() < 0.1 || shockwaveRadius > 0) {
                hudCtx.globalAlpha = 0.6;
                hudCtx.fillStyle = '#ffff00';
                hudCtx.fillRect(0, 0, hudCanvas.width, hudCanvas.height);
                hudCtx.globalAlpha = 1;
            }
        }
        setInterval(drawHUD, 100);

        // TriadSynapse Glyph
        const glyphCanvas = document.getElementById('triad-glyph');
        const glyphCtx = glyphCanvas.getContext('2d');
        glyphCanvas.width = 120;
        glyphCanvas.height = 120;
        function drawGlyph() {
            glyphCtx.clearRect(0, 0, glyphCanvas.width, glyphCanvas.height);
            glyphCtx.strokeStyle = '#ffff00';
            glyphCtx.lineWidth = 3;
            glyphCtx.beginPath();
            const offset = Math.sin(Date.now() * 0.003) * 7;
            glyphCtx.moveTo(60, 20 + offset);
            glyphCtx.lineTo(90 + offset, 90);
            glyphCtx.lineTo(30 - offset, 90);
            glyphCtx.closePath();
            glyphCtx.stroke();
            if (Math.random() < 0.1 || shockwaveRadius > 0) {
                glyphCtx.globalAlpha = 0.8;
                glyphCtx.fillStyle = '#ff00ff';
                glyphCtx.fill();
                glyphCtx.globalAlpha = 1;
            }
        }
        setInterval(drawGlyph, 50);

        // Cyber-Dicks
        const cyberDicks = document.getElementById('cyber-dicks');
        function addCyberDick() {
            if (Math.random() < 0.05) {
                const dick = document.createElement('div');
                dick.className = 'cyber-dick';
                dick.textContent = '8==D';
                const posX = Math.random() * (window.innerWidth - 50);
                const posY = Math.random() * (window.innerHeight - 50);
                dick.style.left = `${posX}px`;
                dick.style.top = `${posY}px`;
                cyberDicks.appendChild(dick);
                dick.style.opacity = '1';
                setTimeout(() => {
                    dick.style.opacity = '0';
                    setTimeout(() => dick.remove(), 200);
                }, 300);
            }
        }
        setInterval(addCyberDick, 100);

        // Neural Orb with TriadSynapse
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(window.innerWidth * 0.5, window.innerHeight * 0.5);
        document.getElementById('neural-orb').appendChild(renderer.domElement);
        const orbGeometry = new THREE.SphereGeometry(2, 32, 32);
        const orbMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: true });
        const orb = new THREE.Mesh(orbGeometry, orbMaterial);
        scene.add(orb);
        const triadNodes = [
            new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), new THREE.MeshBasicMaterial({ color: 0xff3333 })),
            new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), new THREE.MeshBasicMaterial({ color: 0xff3333 })),
            new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), new THREE.MeshBasicMaterial({ color: 0xff3333 }))
        ];
        triadNodes[0].position.set(2, 2, 0);
        triadNodes[1].position.set(-2, 2, 0);
        triadNodes[2].position.set(0, -2, 0);
        triadNodes.forEach(node => scene.add(node));
        const superNode = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
        superNode.position.set(0, 0, 0);
        scene.add(superNode);
        const particles = new THREE.Points(
            new THREE.BufferGeometry().setFromPoints(
                Array.from({ length: 1000 }, () => new THREE.Vector3(
                    Math.random() * 10 - 5, Math.random() * 10 - 5, Math.random() * 10 - 5
                ))
            ),
            new THREE.PointsMaterial({ color: 0xff3333, size: 0.05 })
        );
        scene.add(particles);
        camera.position.z = 5;
        document.addEventListener('mousemove', (e) => {
            orb.rotation.x = e.clientY * 0.005;
            orb.rotation.y = e.clientX * 0.005;
            triadNodes.forEach((node, i) => {
                const t = Date.now() * 0.003 + i;
                node.position.x = Math.sin(t) * 2.5;
                node.position.y = Math.cos(t) * 2.5;
                if (Math.random() < 0.15 || shockwaveRadius > 0) {
                    node.position.lerp(new THREE.Vector3(0, 0, 0), 0.1);
                    node.material.color.set(0xffff00);
                    setTimeout(() => node.material.color.set(0xff3333), 200);
                }
            });
        });
        function animate() {
            requestAnimationFrame(animate);
            orb.rotation.z += 0.007;
            particles.rotation.z += 0.004;
            if (Math.random() < 0.15 || shockwaveRadius > 0) {
                particles.geometry.attributes.position.array.forEach((_, i) => {
                    if (i % 3 === 0) {
                        particles.geometry.attributes.position.array[i] += (Math.random() - 0.5) * 0.5;
                        particles.geometry.attributes.position.array[i + 1] += (Math.random() - 0.5) * 0.5;
                    }
                });
                particles.geometry.attributes.position.needsUpdate = true;
            }
            renderer.render(scene, camera);
        }
        animate();

        // Neural Net Canvas
        const canvas = document.createElement('canvas');
        canvas.style.position = 'absolute';
        canvas.style.top = '0';
        canvas.style.left = '0';
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        canvas.style.zIndex = '-1';
        canvas.style.opacity = '0.4';
        document.querySelector('main').appendChild(canvas);
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        function drawNeuralNet() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = `rgba(255, 0, 255, ${Math.min(1, window.scrollY / 500)})`;
            ctx.lineWidth = 3;
            for (let i = 0; i < 6; i++) {
                ctx.beginPath();
                ctx.arc(100 + i * 150, 200 + Math.sin(Date.now() * 0.002) * 40, 12, 0, Math.PI * 2);
                ctx.stroke();
                if (i < 5) {
                    ctx.moveTo(100 + i * 150, 200 + Math.sin(Date.now() * 0.002) * 40);
                    ctx.lineTo(100 + (i + 1) * 150, 200 + Math.sin(Date.now() * 0.002) * 40);
                    ctx.stroke();
                }
            }
        }
        drawNeuralNet();
        window.addEventListener('scroll', drawNeuralNet);
        setInterval(drawNeuralNet, 50);

        // Glitchy Text Swap
        function glitchText() {
            if (Math.random() < 0.15) {
                const textElements = document.querySelectorAll('.neon-text');
                textElements.forEach(el => {
                    const original = el.textContent;
                    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789∆⚡Ω∑';
                    let glitched = '';
                    for (let char of original) {
                        if (Math.random() < 0.3 && char !== ' ') glitched += chars[Math.floor(Math.random() * chars.length)];
                        else glitched += char;
                    }
                    el.textContent = glitched;
                    el.style.textShadow = '0 0 15px #ffff00';
                    setTimeout(() => {
                        el.textContent = original;
                        el.style.textShadow = '0 0 5px #ff00ff, 0 0 15px #ff00ff, 0 0 25px #ff00ff';
                    }, 150);
                });
            }
        }
        setInterval(glitchText, 100);
    </script>
</body>
</html>
